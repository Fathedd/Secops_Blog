[
  {
    "objectID": "posts/Messing with Angr - angrctf_00/index.html",
    "href": "posts/Messing with Angr - angrctf_00/index.html",
    "title": "Messing with Angr - angrctf_00",
    "section": "",
    "text": "I have never worked with angr before. I just heard about it a few days ago and decided “Hey lets get our hands dirty”. Dirty they got indeed, but it was 100% worth it. We start our journey in Arch Linux. Installing angr on arch is… troublesome. I eventually got angr-management to work, but it didn’t like working, I wasn’t motivated enough to get it working (didnt matter anyway as due to another story I figured out my cpu for some reason no longer liked arch’s kernel, and kept erroring out due to cpu lock). I also wasn’t motivated enough to solve that, I’m trying to do some binary stuff haha.\n\n\nAs much as I do not like windows, I went over to windows, booted up a vm of Kali, and got cooking away.\nAfter getting all the basic kali stuff out of the way. We installed rizin_cutter and pulled the git project.\nPulling the crackme from github:\ngit clone https://github.com/jakespringer/angr_ctf.git\ncd angr_ctf\npython3 -m venv .venv\nsource .venv/bin/activate\npip install -r requirements.txt\nnow we should have a directory that has these few files:  We have the source code, thats a bonus if we get stuck.\n\n\n\nOn my kali system we run into issues with gcc not having the headers it needs. To fix this\nsudo apt install gcc-multilib\nTo setup a challenge file you can use the packages.py then the directory containing the challenge. What we are going to do is just cd into the directory and build it there:\ncd 00_angr_find/\npython3 generate.py 00_angr_find.c.jinja angrfind\nNow we should have a binary file we can work with:\n Lets run the program to see what she does  Okay. Program runs, asks for input, if input does not match hardcoded parameters we exit. Simple enough.\n\n\nLets open cutter and tear into it. Make sure to load in write mode as we are going to have a little patching fun…. because we can lol.\n\nYou should see a similar dashboard. I call cutter a modern version of ghidra. Cutter uses Rizins framework, but Rizin and Ghidra are closely related through the existence of the rz-ghidra plugin. This plugin integrates the Ghidra decompiler engine into Rizin and Rizin-Cutter, allowing the Ghidra deep sleigh decompiler to work seamlessly within these environments.\nThe first page is any and all information you would need about the binary in a fancy format.\nOver on the left is the imports. Looks like we have found main. Thats great! Lets go to main. In the screenshot I am using AT&T Syntax. I use at&t as I found it easier to quickly read. To switch yours to AT&T to see the difference and decide for yourself. Go to the global menu at the top &gt; Edit &gt; Preferences &gt; Disassembly.\n\nWe will want to take a look at our strings to find the disassembly for the function we are trying to crack. \nWe want to switch over to the disassembly tab making sure we have the following selected:\n0x0804a038       ;-- str.Good_Job.:\n0x0804a038          .string \"Good Job.\" ; len=10\nWack X (or right click and click “xrefs”) and you should see the xrefs to the functions calling the string:\n\nLets head over to see where this is being called in main\n\nThis is the goods. We see the strcmp then the jump to a different address (which is highlighted in screenshot). If we want we can view this in the decompiler as well.\n\nLooking at this in a fun perspective, we have three options here. - Finding a Valid key ourselves (time consuming) - Patching to bypass (Too Skiddy) - Finding a Valid key with Angr. (preferred)\nIn the following sections we are going to go over using the angr framework."
  },
  {
    "objectID": "posts/Messing with Angr - angrctf_00/index.html#finally-getting-an-environment-to-work-with",
    "href": "posts/Messing with Angr - angrctf_00/index.html#finally-getting-an-environment-to-work-with",
    "title": "Messing with Angr - angrctf_00",
    "section": "",
    "text": "As much as I do not like windows, I went over to windows, booted up a vm of Kali, and got cooking away.\nAfter getting all the basic kali stuff out of the way. We installed rizin_cutter and pulled the git project.\nPulling the crackme from github:\ngit clone https://github.com/jakespringer/angr_ctf.git\ncd angr_ctf\npython3 -m venv .venv\nsource .venv/bin/activate\npip install -r requirements.txt\nnow we should have a directory that has these few files:  We have the source code, thats a bonus if we get stuck."
  },
  {
    "objectID": "posts/Messing with Angr - angrctf_00/index.html#setting-up-the-ctf",
    "href": "posts/Messing with Angr - angrctf_00/index.html#setting-up-the-ctf",
    "title": "Messing with Angr - angrctf_00",
    "section": "",
    "text": "On my kali system we run into issues with gcc not having the headers it needs. To fix this\nsudo apt install gcc-multilib\nTo setup a challenge file you can use the packages.py then the directory containing the challenge. What we are going to do is just cd into the directory and build it there:\ncd 00_angr_find/\npython3 generate.py 00_angr_find.c.jinja angrfind\nNow we should have a binary file we can work with:\n Lets run the program to see what she does  Okay. Program runs, asks for input, if input does not match hardcoded parameters we exit. Simple enough.\n\n\nLets open cutter and tear into it. Make sure to load in write mode as we are going to have a little patching fun…. because we can lol.\n\nYou should see a similar dashboard. I call cutter a modern version of ghidra. Cutter uses Rizins framework, but Rizin and Ghidra are closely related through the existence of the rz-ghidra plugin. This plugin integrates the Ghidra decompiler engine into Rizin and Rizin-Cutter, allowing the Ghidra deep sleigh decompiler to work seamlessly within these environments.\nThe first page is any and all information you would need about the binary in a fancy format.\nOver on the left is the imports. Looks like we have found main. Thats great! Lets go to main. In the screenshot I am using AT&T Syntax. I use at&t as I found it easier to quickly read. To switch yours to AT&T to see the difference and decide for yourself. Go to the global menu at the top &gt; Edit &gt; Preferences &gt; Disassembly.\n\nWe will want to take a look at our strings to find the disassembly for the function we are trying to crack. \nWe want to switch over to the disassembly tab making sure we have the following selected:\n0x0804a038       ;-- str.Good_Job.:\n0x0804a038          .string \"Good Job.\" ; len=10\nWack X (or right click and click “xrefs”) and you should see the xrefs to the functions calling the string:\n\nLets head over to see where this is being called in main\n\nThis is the goods. We see the strcmp then the jump to a different address (which is highlighted in screenshot). If we want we can view this in the decompiler as well.\n\nLooking at this in a fun perspective, we have three options here. - Finding a Valid key ourselves (time consuming) - Patching to bypass (Too Skiddy) - Finding a Valid key with Angr. (preferred)\nIn the following sections we are going to go over using the angr framework."
  },
  {
    "objectID": "posts/Messing with Angr - angrctf_00/index.html#setting-up-a-custom-script",
    "href": "posts/Messing with Angr - angrctf_00/index.html#setting-up-a-custom-script",
    "title": "Messing with Angr - angrctf_00",
    "section": "Setting up a Custom Script",
    "text": "Setting up a Custom Script\nWe are going to shorten the script quite a bit removing all the comments and adding a few nice features.\nMain:\nimport angr\nimport sys\n\ndef main(argv):\n  path_to_binary = argv[1]  # :string\n  project = angr.Project(path_to_binary)\n  initial_state = project.factory.entry_state(\n    add_options = { angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,\n                    angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS}\n  )\n\n  simulation = project.factory.simgr(initial_state)\n\n  faddr = ???\n  baddr = ???\n  print_good_address = faddr  # :integer (probably in hexadecimal)\n  simulation.explore(find=print_good_address, avoid = baddr)\n\n  if len(simulation.found) &gt; 0:\n    solution_state = simulation.found[0]\n\n    print(\"[*] Flag found: \" + solution_state.posix.dumps(sys.stdin.fileno()).decode())\n  else:\n    raise Exception(f'Could not find Path to address {hex(faddr)}')\n\nif __name__ == '__main__':\n  main(sys.argv)\nWhat we have decided to do here is do the standard project setup but we will be passing the program we want to load as an argument to the program with\nSnippet:\ndef main(argv):\n  path_to_binary = argv[1]  # :string\nAs well we are going to have some basic error handling to prevent some headbashing (if needed)\nSnippet:\n  if len(simulation.found) &gt; 0:\n    solution_state = simulation.found[0]\n\n    print(\"[*] Flag found: \" + solution_state.posix.dumps(sys.stdin.fileno()).decode())\n  else:\n    raise Exception(f'Could not find Path to address {hex(faddr)}')\nIf the length of the data we receive is 0 we error out. For good measure we include the address we were targeting in the error output."
  },
  {
    "objectID": "posts/Messing with Angr - angrctf_00/index.html#final-setup",
    "href": "posts/Messing with Angr - angrctf_00/index.html#final-setup",
    "title": "Messing with Angr - angrctf_00",
    "section": "Final Setup",
    "text": "Final Setup\nGreat you have gotten this far! We are almost done. The only thing we have to do now is give our script the address we want to find, then the address we want to avoid.\nIf we go back to cutter we can see:\n\nWe see our good address is 0x080492bd and the bad address 0x080492ab\nwe simply change\n  simulation = project.factory.simgr(initial_state)\n\n  faddr = ??? --&gt; 0x08492bd\n  baddr = ??? --&gt; 0x08492ab\n  print_good_address = faddr  # :integer (probably in hexadecimal)\n  simulation.explore(find=print_good_address, avoid = baddr)\nNow if we do\npython3 customscript.py angrfind\nwe should get the flag:\n\nAwesome! We just used symbolic execution to force our way in!"
  },
  {
    "objectID": "posts/Messing with Angr - angrctf_00/index.html#bonus-patching-and-reconstructing-the-binary",
    "href": "posts/Messing with Angr - angrctf_00/index.html#bonus-patching-and-reconstructing-the-binary",
    "title": "Messing with Angr - angrctf_00",
    "section": "Bonus: Patching and Reconstructing the Binary",
    "text": "Bonus: Patching and Reconstructing the Binary\nThis is just super fun to do. We are just going to patch the binary to tell us Good_Job. This binary is actually a little tricky to patch. I was going to include this section in this blog post. But patching a relatively complex function is a whole other topic we will cover in an up and coming blog post."
  },
  {
    "objectID": "posts/ddwrt-embedded-firmware/index.html",
    "href": "posts/ddwrt-embedded-firmware/index.html",
    "title": "Flashing Embedded Routers",
    "section": "",
    "text": "What is DDWRT?\nDD-WRT is a Linux-based firmware for embedded wireless routers and access points, originally designed for the Linksys WRT54G series but now compatible with a wide range of models. Developed by Sebastian Gottschall, also known as “BrainSlayer,” DD-WRT turns a basic off the shelf router into a enterprise beast to be reckoned with. Features include, advanced quality of service, wireless bridging, Radius Authentication, VLANs, SIP, support for VPNs. (if routers powerful enough you could even run snort from the router hardware.) This open-source firmware provides a robust alternative to standard manufacturer firmware, aiming to increase the functionality and performance of supported devices. The project, which began as a response to commercial firmware that limited user control, continues to evolve, offering features not found in original or even other third-party firmware solutions\nOther embedded System alternative (only supports broadcom chipsets): Fresh Tomato\n\n\nInstallation/Flash\n\nStep 1: Download the Correct Firmware\nNavigate to the router database. Visit the DD-WRT Router Database and search the database to find the firmware specific to your router model. If it does not show up your device is not supported. However, it’s important to note:\n\nNever download router firmware files directly from the router database. Always check the forums for the latest advice and links to firmware as these are often more up to date and reliable.\nThere are multiple files, Init flash and update flash. The initial flash installs ddwrt onto your router, the next ‘flash’ is updating ddwrt\n\n\n\nStep 2: Fish the site for the forum post for your installation\nYou will find this forum to be a bit messy. But don’t be scared its relatively simple. In the database you will see a link “DD-WRT Wiki: Installation Instructions”\n\nEventually we will find the proper install link And land on this page:\n\n\nClick the latest build it, it will be the build-date and firmware version:\n \nFind your router:\n\nDownload both files. The factory-to-ddwrt will be the file you use for NetGear Genie (or whatever your routers gui’s name is)\n\n\n\nStep 3: Prepare for Installation\n\nBackup your current settings: Before proceeding, save your current router settings just in case you need to revert.\nReset your router to factory defaults: This can prevent issues during the flashing process. (Proceed to your routers documentation for that)\n\n\n\nStep 4: Flash Firmware via Web GUI\n\nConnect your computer to the router using an Ethernet cable.\nAccess your router’s default admin page (usually 192.168.1.1).\nNavigate to the “Administration” tab and select “Firmware Upgrade”.\nClick “Browse” and select the DD-WRT firmware file you downloaded.\nClick “Upgrade” and wait for the process to complete. Do not interrupt this process as it might brick your router.\n\nMy Routers Gui looks like this:\n\nFor more information about bricking visit DD-WRT wiki\n\n\nStep 5: After Installation\n\nWait at least 5 minutes after the upgrade tool says it is complete to ensure the changes are fully applied.\nReboot your router manually by unplugging it from power and plugging it back in.\nAccess the DD-WRT control panel by entering 192.168.1.1 in your browser.\n\n\n\nStep 6: Final Setup\n\nReconfigure your router settings according to your needs. You might want to set up security settings, Wi-Fi passwords, and network names (SSIDs) again.\nExplore DD-WRT’s features such as setting up a VPN, adjusting QoS settings, or setting up a guest network.\n\n\n\nTroubleshooting\nIf you encounter issues:\n\nCheck if your router is truly bricked by trying to access the recovery mode.\nRefer to the DD-WRT wiki for troubleshooting tips or post a question in the DD-WRT forums.\n\nBy following these steps, you should be able to successfully install DD-WRT on your router and enjoy the enhanced features it offers. Remember, always proceed with caution and follow the instructions specific to your router model."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog\nThis blog documents my journey in the Security Realm. Offering both Technical and Shop talk. I have been doing Security Operations for 11 years. Starting off with Blackhat operations when I was a lot younger.\nNowadays I ethically explore both Red and Blue team topics. Some in depth. Stick around, you may learn something or find a resource not previously known!\nLanguages: Rust, C/C++, ObjC, Swift, Python, Ruby, Solidity, Java, Javascript, Lisp"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Index",
    "section": "",
    "text": "Messing with Angr - angrctf_00\n\n\n\n\n\n\nReverse\n\n\nPwn\n\n\nOffSec\n\n\n\n\n\n\n\n\n\nMay 31, 2024\n\n\nRock3t\n\n\n\n\n\n\n\n\n\n\n\n\niFindMem Development\n\n\n\n\n\n\niOS\n\n\nDevelopment\n\n\nOffSec\n\n\n\n\n\n\n\n\n\nMay 16, 2024\n\n\nRock3t\n\n\n\n\n\n\n\n\n\n\n\n\nFlashing Embedded Routers\n\n\n\n\n\n\nEmbedded Systems\n\n\nBlue\n\n\n\n\n\n\n\n\n\nApr 24, 2024\n\n\nRock3t\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/iFindMem Dev Notes/index.html",
    "href": "posts/iFindMem Dev Notes/index.html",
    "title": "iFindMem Development",
    "section": "",
    "text": "Why did I get into iOS?\nTo be 100% honest. I have zero clue why I am so into iOS. I think it stims from being a child wanting my phone to do something not many iPhones do. This blog post is going to be not as structured as the others. We are mostly going to talk about the notes I took, what I learned going down this rabbit hole, and how I applied what I learned. Hopefully seeing how someone else goes about business will help yourself.\nI’ve never really worked with a project this big before so I had a lot to learn.\n\n\nWhats the Goal?\nThe goal was to be able to choose a process and monitor/sparse the memory wtih r/w permissions of protected ipas. There isn’t really a tweak that does this, and the free ones I found were, not using anything useful for bypassing or closed source. I started github diving and found a 5yr old project RevelariOS. I took a look at the code compiled it, and realized “this is not a bad boilerplate to continue with”, and thats where this journey started.\n\n\nStructure of the orginal project\nThe orginal project structure is a little weird.\n\nOverall its a iOS application/tool so its going to have the default iOS layout. But whats weird is the binary/tool was pre-compiled and just thrown into the package layout. So you’re not actually compiling and installing the package. I don’t like this. This is where the Theos community comes in (specifically Leptos).\n\n\nTrying to Compile the binary\nThis became a nightmare for me. Half of the code was outdated and I’ve never worked with something like this before, so I went searching for people that have haha. within a bit we had some solutions to the issues I had. Screenshots provided below to all of the madness.\n\nDebug Dump:\n```==&gt; Compiling iFindMemCore.c (arm64e)… iFindMemCore.c:65:13: error: call to undeclared library function ‘exit’ with type ‘void (int) attribute((noreturn))’; ISO C99 and later do not support implicit function declarations [-Wimplicit-function-declaration] EXIT ^ ./mem.h:22:52: note: expanded from macro ‘EXIT’ #define EXIT printf(ERROR”Exiting iFindMem…“); exit(0); ^ iFindMemCore.c:65:13: note: include the header &lt;stdlib.h&gt; or explicitly provide a declaration for ‘exit’ ./mem.h:22:52: note: expanded from macro ‘EXIT’ #define EXIT printf(ERROR”Exiting iFindMem…“); exit(0); ^ iFindMemCore.c:76:25: error: call to undeclared library function ‘strtol’ with type ‘long (const char , char , int)’; ISO C99 and later do not support implicit function declarations [-Wimplicit-function-declaration] pid = (int) strtol(args[1], NULL, 0); ^ iFindMemCore.c:76:25: note: include the header &lt;stdlib.h&gt; or explicitly provide a declaration for ’strtol’ iFindMemCore.c:113:56: error: incompatible pointer types passing ’vm_address_t ()[256]’ (aka ’unsigned long ()[256]’) to parameter of type ’vm_address_t ’ (aka ’unsigned long ’) [-Werror,-Wincompatible-pointer-types] search_data(task, false, false, base, end, &out, &resultnum, args[1]); ^~~~ ./mem.h:59:41: note: passing argument to parameter ’outaddr’ here vm_address_t outaddr[SEARCH_MAX], ^ iFindMemCore.c:123:55: error: incompatible pointer types passing ’vm_address_t ()[256]’ (aka ’unsigned long ()[256]’) to parameter of type ’vm_address_t ’ (aka ’unsigned long ’) [-Werror,-Wincompatible-pointer-types] search_data(task, false, true, base, end, &out, &resultnum, args[1]); ^~~~ ./mem.h:59:41: note: passing argument to parameter ’outaddr’ here vm_address_t outaddr[SEARCH_MAX], ^ iFindMemCore.c:133:55: error: incompatible pointer types passing ’vm_address_t ()[256]’ (aka ’unsigned long ()[256]’) to parameter of type ’vm_address_t ’ (aka ’unsigned long ’) [-Werror,-Wincompatible-pointer-types] search_data(task, true, false, base, end, &out, &resultnum, args[1]); ^~~~ ./mem.h:59:41: note: passing argument to parameter ’outaddr’ here vm_address_t outaddr[SEARCH_MAX], ^ iFindMemCore.c:143:54: error: incompatible pointer types passing ’vm_address_t ()[256]’ (aka ’unsigned long ()[256]’) to parameter of type ’vm_address_t ’ (aka ’unsigned long ’) [-Werror,-Wincompatible-pointer-types] search_data(task, true, true, base, end, &out, &resultnum, args[1]); ^~~~ ./mem.h:59:41: note: passing argument to parameter ’outaddr’ here vm_address_t outaddr[SEARCH_MAX], ^ iFindMemCore.c:152:37: error: incompatible pointer to integer conversion passing ’vm_address_t[256]’ (aka ’unsigned long[256]’) to parameter of type ’vm_address_t’ (aka ’unsigned long’) [-Werror,-Wint-conversion] write_data(task, false, out, args[1]); ^~~ ./mem.h:50:39: note: passing argument to parameter ’addr’ here vm_address_t addr, ^ iFindMemCore.c:159:36: error: incompatible pointer to integer conversion passing ’vm_address_t[256]’ (aka ’unsigned long[256]’) to parameter of type ’vm_address_t’ (aka ’unsigned long’) [-Werror,-Wint-conversion] write_data(task, true, out, args[1]); ^~~ ./mem.h:50:39: note: passing argument to parameter ’addr’ here vm_address_t addr, ^ iFindMemCore.c:12:10: error: unused variable ’in’ [-Werror,-Wunused-variable] char in[MAX_INPUT_DATA]; ^ 9 errors generated. make[4]:  [/home/zen/.libs/~/theos/makefiles/instance/rules.mk:309: /home/zen/Documents/gitrepos/jbtweaks/iFindMem/iFindMem-App/.theos/obj/debug/arm64e/iFindMemCore.c.0999093b.o] Error 1 ==&gt; Compiling iFindMemCore.c (arm64)… iFindMemCore.c:65:13: error: call to undeclared library function ’exit’ with type ‘void (int) attribute((noreturn))’; ISO C99 and later do not support implicit function declarations [-Wimplicit-function-declaration] EXIT ^ ./mem.h:22:52: note: expanded from macro ‘EXIT’ #define EXIT printf(ERROR”Exiting iFindMem…“); exit(0); ^ iFindMemCore.c:65:13: note: include the header &lt;stdlib.h&gt; or explicitly provide a declaration for ‘exit’ ./mem.h:22:52: note: expanded from macro ‘EXIT’ #define EXIT printf(ERROR”Exiting iFindMem…“); exit(0); ^ iFindMemCore.c:76:25: error: call to undeclared library function ‘strtol’ with type ‘long (const char , char , int)’; ISO C99 and later do not support implicit function declarations [-Wimplicit-function-declaration] pid = (int) strtol(args[1], NULL, 0); ^ iFindMemCore.c:76:25: note: include the header &lt;stdlib.h&gt; or explicitly provide a declaration for ’strtol’ iFindMemCore.c:113:56: error: incompatible pointer types passing ’vm_address_t ()[256]’ (aka ’unsigned long ()[256]’) to parameter of type ’vm_address_t ’ (aka ’unsigned long ’) [-Werror,-Wincompatible-pointer-types] search_data(task, false, false, base, end, &out, &resultnum, args[1]); ^~~~ ./mem.h:59:41: note: passing argument to parameter ’outaddr’ here vm_address_t outaddr[SEARCH_MAX], ^ iFindMemCore.c:123:55: error: incompatible pointer types passing ’vm_address_t ()[256]’ (aka ’unsigned long ()[256]’) to parameter of type ’vm_address_t ’ (aka ’unsigned long ’) [-Werror,-Wincompatible-pointer-types] search_data(task, false, true, base, end, &out, &resultnum, args[1]); ^~~~ ./mem.h:59:41: note: passing argument to parameter ’outaddr’ here vm_address_t outaddr[SEARCH_MAX], ^ iFindMemCore.c:133:55: error: incompatible pointer types passing ’vm_address_t ()[256]’ (aka ’unsigned long ()[256]’) to parameter of type ’vm_address_t ’ (aka ’unsigned long ’) [-Werror,-Wincompatible-pointer-types] search_data(task, true, false, base, end, &out, &resultnum, args[1]); ^~~~ ./mem.h:59:41: note: passing argument to parameter ’outaddr’ here vm_address_t outaddr[SEARCH_MAX], ^ iFindMemCore.c:143:54: error: incompatible pointer types passing ’vm_address_t ()[256]’ (aka ’unsigned long ()[256]’) to parameter of type ’vm_address_t ’ (aka ’unsigned long ’) [-Werror,-Wincompatible-pointer-types] search_data(task, true, true, base, end, &out, &resultnum, args[1]); ^~~~ ./mem.h:59:41: note: passing argument to parameter ’outaddr’ here vm_address_t outaddr[SEARCH_MAX], ^ iFindMemCore.c:152:37: error: incompatible pointer to integer conversion passing ’vm_address_t[256]’ (aka ’unsigned long[256]’) to parameter of type ’vm_address_t’ (aka ’unsigned long’) [-Werror,-Wint-conversion] write_data(task, false, out, args[1]); ^~~ ./mem.h:50:39: note: passing argument to parameter ’addr’ here vm_address_t addr, ^ iFindMemCore.c:159:36: error: incompatible pointer to integer conversion passing ’vm_address_t[256]’ (aka ’unsigned long[256]’) to parameter of type ’vm_address_t’ (aka ’unsigned long’) [-Werror,-Wint-conversion] write_data(task, true, out, args[1]); ^~~ ./mem.h:50:39: note: passing argument to parameter ’addr’ here vm_address_t addr, ^ iFindMemCore.c:12:10: error: unused variable ’in’ [-Werror,-Wunused-variable] char in[MAX_INPUT_DATA]; ^ 9 errors generated. make[4]:  [/home/zen/.libs/~/theos/makefiles/instance/rules.mk:309: /home/zen/Documents/gitrepos/jbtweaks/iFindMem/iFindMem-App/.theos/obj/debug/arm64/iFindMemCore.c.79c9a250.o] Error 1 ==&gt; Compiling mem.c (arm64)… mem.c:66:40: error: format specifies type ’unsigned long’ but the argument has type ‘byte_t’ (aka ‘unsigned char’) [-Werror,-Wformat] printf(”%lx “, readOut[i]); ~~~ ^~~~~~~~~~ %hhx mem.c:115:38: error: call to undeclared library function ‘strtol’ with type ‘long (const char , char , int)’; ISO C99 and later do not support implicit function declarations [-Wimplicit-function-declaration] writebyte[i] = (uint8_t) strtol(tocmpbyte[i], NULL, 16); ^ mem.c:115:38: note: include the header &lt;stdlib.h&gt; or explicitly provide a declaration for ’strtol’ mem.c:118:37: error: incompatible pointer to integer conversion passing ’byte_t ()[strlen(in) / 2]’ (aka ’unsigned char ()[strlen(in) / 2]’) to parameter of type ’vm_offset_t’ (aka ’unsigned long’) [-Werror,-Wint-conversion] kret = vm_write(task, addr, &writebyte, sizeof(writebyte)); ^~~~~~~~~~ /home/zen/.libs/~/theos/sdks/iPhoneOS16.5.sdk/usr/include/mach/vm_map.h:184:14: note: passing argument to parameter ’data’ here vm_offset_t data, ^ mem.c:127:37: error: incompatible pointer to integer conversion passing ’byte_t ()[strlen(in)]’ (aka ’unsigned char ()[strlen(in)]’) to parameter of type ’vm_offset_t’ (aka ’unsigned long’) [-Werror,-Wint-conversion] kret = vm_write(task, addr, &writebyte, sizeof(writebyte)); ^~~~~~~~~~ /home/zen/.libs/~/theos/sdks/iPhoneOS16.5.sdk/usr/include/mach/vm_map.h:184:14: note: passing argument to parameter ’data’ here vm_offset_t data, ^ mem.c:98:12: error: unused variable ’bytes’ [-Werror,-Wunused-variable] size_t bytes = strlen(in); ^ mem.c:194:38: error: incompatible integer to pointer conversion assigning to ’vm_address_t ’ (aka ’unsigned long ’) from ’unsigned long’ [-Werror,-Wint-conversion] outaddr = baseaddr+i; ^ ~~~~~~~~~~ mem.c:199:53: error: incompatible integer to pointer conversion assigning to ’vm_address_t ’ (aka ’unsigned long ’) from ’unsigned long’ [-Werror,-Wint-conversion] (outaddr + foundtotal) = baseaddr+i; ^ ~~~~~~~~~~ 7 errors generated. make[4]:  [/home/zen/.libs/~/theos/makefiles/instance/rules.mk:309: /home/zen/Documents/gitrepos/jbtweaks/iFindMem/iFindMem-App/.theos/obj/debug/arm64/mem.c.79c9a250.o] Error 1 ==&gt; Compiling mem.c (arm64e)… mem.c:66:40: error: format specifies type ’unsigned long’ but the argument has type ‘byte_t’ (aka ‘unsigned char’) [-Werror,-Wformat] printf(”%lx “, readOut[i]); ~~~ ^~~~~~~~~~ %hhx mem.c:115:38: error: call to undeclared library function ‘strtol’ with type ’long (const char *, char **, int)‘; ISO C99 and later do not support implicit function declarations [-Wimplicit-function-declaration] writebyte[i] = (uint8_t) strtol(tocmpbyte[i], NULL, 16); ^ mem.c:115:38: note: include the header &lt;stdlib.h&gt; or explicitly provide a declaration for ’strtol’ mem.c:118:37: error: incompatible pointer to integer conversion passing ‘byte_t ()[strlen(in) / 2]’ (aka ’unsigned char ()[strlen(in) / 2]’) to parameter of type ‘vm_offset_t’ (aka ‘unsigned long’) [-Werror,-Wint-conversion] kret = vm_write(task, addr, &writebyte, sizeof(writebyte)); ^~~~~~~~~~ /home/zen/.libs/~/theos/sdks/iPhoneOS16.5.sdk/usr/include/mach/vm_map.h:184:14: note: passing argument to parameter ‘data’ here vm_offset_t data, ^ mem.c:127:37: error: incompatible pointer to integer conversion passing ‘byte_t ()[strlen(in)]’ (aka ’unsigned char ()[strlen(in)]’) to parameter of type ‘vm_offset_t’ (aka ‘unsigned long’) [-Werror,-Wint-conversion] kret = vm_write(task, addr, &writebyte, sizeof(writebyte)); ^~~~~~~~~~ /home/zen/.libs/~/theos/sdks/iPhoneOS16.5.sdk/usr/include/mach/vm_map.h:184:14: note: passing argument to parameter ‘data’ here vm_offset_t data, ^ mem.c:98:12: error: unused variable ‘bytes’ [-Werror,-Wunused-variable] size_t bytes = strlen(in); ^ mem.c:194:38: error: incompatible integer to pointer conversion assigning to ‘vm_address_t ’ (aka ’unsigned long ’) from ‘unsigned long’ [-Werror,-Wint-conversion] outaddr = baseaddr+i; ^ ~~~~~~~~~~ mem.c:199:53: error: incompatible integer to pointer conversion assigning to ‘vm_address_t ’ (aka ’unsigned long ’) from ‘unsigned long’ [-Werror,-Wint-conversion] (outaddr + foundtotal) = baseaddr+i;\n\nYeah So This was a mess…\n\n\nResolving the Garbage Pile mess\nAfter 3 people (Mostly the Theos community) resloving this hot pile. We finally got a working build.\n \n\n\nOkay cool, a tool that… kinda works\nThe frontend application is null void. It will boot but preform zero tasks. The cli however does work, kinda. There is no proper tty to remember commands\nThe cli is really slow. Also have no way to fetch pids from within it, and doing that with\nps aux | grep containers | grep my ass | awk someone elses ass {FS = ” “;}{pid = $2;cid = $7; path = substr($11, index($11,\nyeah Im not doing that. I first wrote a shell script but… that wasn’t enough for me either. So I create another theos package iProcDump to nicely list all of processess with KERN_PROC, nicely sparsing it listing PIDS and Process name. I whipped it up pretty quickly being warmed up from the iFindMem. At some point it would be added to the main application.\n\n\nConclusion\nThere is a lot to be done as I would like to see some sort of decompiler like rizin or ghidra, being able to be used directly. After running iFindMem and find interesting memory addresses, you can start messing with them in a debugger/decompiler right away.\nI at some point have to go back to pwn related stuff, and especially revist assembly to get more into iOS Exploit/Jailbreak Development. I will make a few update posts for huge new releases regarding these topics,"
  }
]