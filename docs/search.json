[
  {
    "objectID": "posts/iFindMem Dev Notes/index.html",
    "href": "posts/iFindMem Dev Notes/index.html",
    "title": "iFindMem Development",
    "section": "",
    "text": "Why did I get into iOS?\nTo be 100% honest. I have zero clue why I am so into iOS. I think it stims from being a child wanting my phone to do something not many iPhones do. This blog post is going to be not as structured as the others. We are mostly going to talk about the notes I took, what I learned going down this rabbit hole, and how I applied what I learned. Hopefully seeing how someone else goes about business will help yourself.\nI’ve never really worked with a project this big before so I had a lot to learn.\n\n\nWhats the Goal?\nThe goal was to be able to choose a process and monitor/sparse the memory wtih r/w permissions of protected ipas. There isn’t really a tweak that does this, and the free ones I found were, not using anything useful for bypassing or closed source. I started github diving and found a 5yr old project RevelariOS. I took a look at the code compiled it, and realized “this is not a bad boilerplate to continue with”, and thats where this journey started.\n\n\nStructure of the orginal project\nThe orginal project structure is a little weird.\n\nOverall its a iOS application/tool so its going to have the default iOS layout. But whats weird is the binary/tool was pre-compiled and just thrown into the package layout. So you’re not actually compiling and installing the package. I don’t like this. This is where the Theos community comes in (specifically Leptos).\n\n\nTrying to Compile the binary\nThis became a nightmare for me. Half of the code was outdated and I’ve never worked with something like this before, so I went searching for people that have haha. within a bit we had some solutions to the issues I had. Screenshots provided below to all of the madness.\n\nDebug Dump:\n```==&gt; Compiling iFindMemCore.c (arm64e)… iFindMemCore.c:65:13: error: call to undeclared library function ‘exit’ with type ‘void (int) attribute((noreturn))’; ISO C99 and later do not support implicit function declarations [-Wimplicit-function-declaration] EXIT ^ ./mem.h:22:52: note: expanded from macro ‘EXIT’ #define EXIT printf(ERROR”Exiting iFindMem…“); exit(0); ^ iFindMemCore.c:65:13: note: include the header &lt;stdlib.h&gt; or explicitly provide a declaration for ‘exit’ ./mem.h:22:52: note: expanded from macro ‘EXIT’ #define EXIT printf(ERROR”Exiting iFindMem…“); exit(0); ^ iFindMemCore.c:76:25: error: call to undeclared library function ‘strtol’ with type ‘long (const char , char , int)’; ISO C99 and later do not support implicit function declarations [-Wimplicit-function-declaration] pid = (int) strtol(args[1], NULL, 0); ^ iFindMemCore.c:76:25: note: include the header &lt;stdlib.h&gt; or explicitly provide a declaration for ’strtol’ iFindMemCore.c:113:56: error: incompatible pointer types passing ’vm_address_t ()[256]’ (aka ’unsigned long ()[256]’) to parameter of type ’vm_address_t ’ (aka ’unsigned long ’) [-Werror,-Wincompatible-pointer-types] search_data(task, false, false, base, end, &out, &resultnum, args[1]); ^~~~ ./mem.h:59:41: note: passing argument to parameter ’outaddr’ here vm_address_t outaddr[SEARCH_MAX], ^ iFindMemCore.c:123:55: error: incompatible pointer types passing ’vm_address_t ()[256]’ (aka ’unsigned long ()[256]’) to parameter of type ’vm_address_t ’ (aka ’unsigned long ’) [-Werror,-Wincompatible-pointer-types] search_data(task, false, true, base, end, &out, &resultnum, args[1]); ^~~~ ./mem.h:59:41: note: passing argument to parameter ’outaddr’ here vm_address_t outaddr[SEARCH_MAX], ^ iFindMemCore.c:133:55: error: incompatible pointer types passing ’vm_address_t ()[256]’ (aka ’unsigned long ()[256]’) to parameter of type ’vm_address_t ’ (aka ’unsigned long ’) [-Werror,-Wincompatible-pointer-types] search_data(task, true, false, base, end, &out, &resultnum, args[1]); ^~~~ ./mem.h:59:41: note: passing argument to parameter ’outaddr’ here vm_address_t outaddr[SEARCH_MAX], ^ iFindMemCore.c:143:54: error: incompatible pointer types passing ’vm_address_t ()[256]’ (aka ’unsigned long ()[256]’) to parameter of type ’vm_address_t ’ (aka ’unsigned long ’) [-Werror,-Wincompatible-pointer-types] search_data(task, true, true, base, end, &out, &resultnum, args[1]); ^~~~ ./mem.h:59:41: note: passing argument to parameter ’outaddr’ here vm_address_t outaddr[SEARCH_MAX], ^ iFindMemCore.c:152:37: error: incompatible pointer to integer conversion passing ’vm_address_t[256]’ (aka ’unsigned long[256]’) to parameter of type ’vm_address_t’ (aka ’unsigned long’) [-Werror,-Wint-conversion] write_data(task, false, out, args[1]); ^~~ ./mem.h:50:39: note: passing argument to parameter ’addr’ here vm_address_t addr, ^ iFindMemCore.c:159:36: error: incompatible pointer to integer conversion passing ’vm_address_t[256]’ (aka ’unsigned long[256]’) to parameter of type ’vm_address_t’ (aka ’unsigned long’) [-Werror,-Wint-conversion] write_data(task, true, out, args[1]); ^~~ ./mem.h:50:39: note: passing argument to parameter ’addr’ here vm_address_t addr, ^ iFindMemCore.c:12:10: error: unused variable ’in’ [-Werror,-Wunused-variable] char in[MAX_INPUT_DATA]; ^ 9 errors generated. make[4]:  [/home/zen/.libs/~/theos/makefiles/instance/rules.mk:309: /home/zen/Documents/gitrepos/jbtweaks/iFindMem/iFindMem-App/.theos/obj/debug/arm64e/iFindMemCore.c.0999093b.o] Error 1 ==&gt; Compiling iFindMemCore.c (arm64)… iFindMemCore.c:65:13: error: call to undeclared library function ’exit’ with type ‘void (int) attribute((noreturn))’; ISO C99 and later do not support implicit function declarations [-Wimplicit-function-declaration] EXIT ^ ./mem.h:22:52: note: expanded from macro ‘EXIT’ #define EXIT printf(ERROR”Exiting iFindMem…“); exit(0); ^ iFindMemCore.c:65:13: note: include the header &lt;stdlib.h&gt; or explicitly provide a declaration for ‘exit’ ./mem.h:22:52: note: expanded from macro ‘EXIT’ #define EXIT printf(ERROR”Exiting iFindMem…“); exit(0); ^ iFindMemCore.c:76:25: error: call to undeclared library function ‘strtol’ with type ‘long (const char , char , int)’; ISO C99 and later do not support implicit function declarations [-Wimplicit-function-declaration] pid = (int) strtol(args[1], NULL, 0); ^ iFindMemCore.c:76:25: note: include the header &lt;stdlib.h&gt; or explicitly provide a declaration for ’strtol’ iFindMemCore.c:113:56: error: incompatible pointer types passing ’vm_address_t ()[256]’ (aka ’unsigned long ()[256]’) to parameter of type ’vm_address_t ’ (aka ’unsigned long ’) [-Werror,-Wincompatible-pointer-types] search_data(task, false, false, base, end, &out, &resultnum, args[1]); ^~~~ ./mem.h:59:41: note: passing argument to parameter ’outaddr’ here vm_address_t outaddr[SEARCH_MAX], ^ iFindMemCore.c:123:55: error: incompatible pointer types passing ’vm_address_t ()[256]’ (aka ’unsigned long ()[256]’) to parameter of type ’vm_address_t ’ (aka ’unsigned long ’) [-Werror,-Wincompatible-pointer-types] search_data(task, false, true, base, end, &out, &resultnum, args[1]); ^~~~ ./mem.h:59:41: note: passing argument to parameter ’outaddr’ here vm_address_t outaddr[SEARCH_MAX], ^ iFindMemCore.c:133:55: error: incompatible pointer types passing ’vm_address_t ()[256]’ (aka ’unsigned long ()[256]’) to parameter of type ’vm_address_t ’ (aka ’unsigned long ’) [-Werror,-Wincompatible-pointer-types] search_data(task, true, false, base, end, &out, &resultnum, args[1]); ^~~~ ./mem.h:59:41: note: passing argument to parameter ’outaddr’ here vm_address_t outaddr[SEARCH_MAX], ^ iFindMemCore.c:143:54: error: incompatible pointer types passing ’vm_address_t ()[256]’ (aka ’unsigned long ()[256]’) to parameter of type ’vm_address_t ’ (aka ’unsigned long ’) [-Werror,-Wincompatible-pointer-types] search_data(task, true, true, base, end, &out, &resultnum, args[1]); ^~~~ ./mem.h:59:41: note: passing argument to parameter ’outaddr’ here vm_address_t outaddr[SEARCH_MAX], ^ iFindMemCore.c:152:37: error: incompatible pointer to integer conversion passing ’vm_address_t[256]’ (aka ’unsigned long[256]’) to parameter of type ’vm_address_t’ (aka ’unsigned long’) [-Werror,-Wint-conversion] write_data(task, false, out, args[1]); ^~~ ./mem.h:50:39: note: passing argument to parameter ’addr’ here vm_address_t addr, ^ iFindMemCore.c:159:36: error: incompatible pointer to integer conversion passing ’vm_address_t[256]’ (aka ’unsigned long[256]’) to parameter of type ’vm_address_t’ (aka ’unsigned long’) [-Werror,-Wint-conversion] write_data(task, true, out, args[1]); ^~~ ./mem.h:50:39: note: passing argument to parameter ’addr’ here vm_address_t addr, ^ iFindMemCore.c:12:10: error: unused variable ’in’ [-Werror,-Wunused-variable] char in[MAX_INPUT_DATA]; ^ 9 errors generated. make[4]:  [/home/zen/.libs/~/theos/makefiles/instance/rules.mk:309: /home/zen/Documents/gitrepos/jbtweaks/iFindMem/iFindMem-App/.theos/obj/debug/arm64/iFindMemCore.c.79c9a250.o] Error 1 ==&gt; Compiling mem.c (arm64)… mem.c:66:40: error: format specifies type ’unsigned long’ but the argument has type ‘byte_t’ (aka ‘unsigned char’) [-Werror,-Wformat] printf(”%lx “, readOut[i]); ~~~ ^~~~~~~~~~ %hhx mem.c:115:38: error: call to undeclared library function ‘strtol’ with type ‘long (const char , char , int)’; ISO C99 and later do not support implicit function declarations [-Wimplicit-function-declaration] writebyte[i] = (uint8_t) strtol(tocmpbyte[i], NULL, 16); ^ mem.c:115:38: note: include the header &lt;stdlib.h&gt; or explicitly provide a declaration for ’strtol’ mem.c:118:37: error: incompatible pointer to integer conversion passing ’byte_t ()[strlen(in) / 2]’ (aka ’unsigned char ()[strlen(in) / 2]’) to parameter of type ’vm_offset_t’ (aka ’unsigned long’) [-Werror,-Wint-conversion] kret = vm_write(task, addr, &writebyte, sizeof(writebyte)); ^~~~~~~~~~ /home/zen/.libs/~/theos/sdks/iPhoneOS16.5.sdk/usr/include/mach/vm_map.h:184:14: note: passing argument to parameter ’data’ here vm_offset_t data, ^ mem.c:127:37: error: incompatible pointer to integer conversion passing ’byte_t ()[strlen(in)]’ (aka ’unsigned char ()[strlen(in)]’) to parameter of type ’vm_offset_t’ (aka ’unsigned long’) [-Werror,-Wint-conversion] kret = vm_write(task, addr, &writebyte, sizeof(writebyte)); ^~~~~~~~~~ /home/zen/.libs/~/theos/sdks/iPhoneOS16.5.sdk/usr/include/mach/vm_map.h:184:14: note: passing argument to parameter ’data’ here vm_offset_t data, ^ mem.c:98:12: error: unused variable ’bytes’ [-Werror,-Wunused-variable] size_t bytes = strlen(in); ^ mem.c:194:38: error: incompatible integer to pointer conversion assigning to ’vm_address_t ’ (aka ’unsigned long ’) from ’unsigned long’ [-Werror,-Wint-conversion] outaddr = baseaddr+i; ^ ~~~~~~~~~~ mem.c:199:53: error: incompatible integer to pointer conversion assigning to ’vm_address_t ’ (aka ’unsigned long ’) from ’unsigned long’ [-Werror,-Wint-conversion] (outaddr + foundtotal) = baseaddr+i; ^ ~~~~~~~~~~ 7 errors generated. make[4]:  [/home/zen/.libs/~/theos/makefiles/instance/rules.mk:309: /home/zen/Documents/gitrepos/jbtweaks/iFindMem/iFindMem-App/.theos/obj/debug/arm64/mem.c.79c9a250.o] Error 1 ==&gt; Compiling mem.c (arm64e)… mem.c:66:40: error: format specifies type ’unsigned long’ but the argument has type ‘byte_t’ (aka ‘unsigned char’) [-Werror,-Wformat] printf(”%lx “, readOut[i]); ~~~ ^~~~~~~~~~ %hhx mem.c:115:38: error: call to undeclared library function ‘strtol’ with type ’long (const char *, char **, int)‘; ISO C99 and later do not support implicit function declarations [-Wimplicit-function-declaration] writebyte[i] = (uint8_t) strtol(tocmpbyte[i], NULL, 16); ^ mem.c:115:38: note: include the header &lt;stdlib.h&gt; or explicitly provide a declaration for ’strtol’ mem.c:118:37: error: incompatible pointer to integer conversion passing ‘byte_t ()[strlen(in) / 2]’ (aka ’unsigned char ()[strlen(in) / 2]’) to parameter of type ‘vm_offset_t’ (aka ‘unsigned long’) [-Werror,-Wint-conversion] kret = vm_write(task, addr, &writebyte, sizeof(writebyte)); ^~~~~~~~~~ /home/zen/.libs/~/theos/sdks/iPhoneOS16.5.sdk/usr/include/mach/vm_map.h:184:14: note: passing argument to parameter ‘data’ here vm_offset_t data, ^ mem.c:127:37: error: incompatible pointer to integer conversion passing ‘byte_t ()[strlen(in)]’ (aka ’unsigned char ()[strlen(in)]’) to parameter of type ‘vm_offset_t’ (aka ‘unsigned long’) [-Werror,-Wint-conversion] kret = vm_write(task, addr, &writebyte, sizeof(writebyte)); ^~~~~~~~~~ /home/zen/.libs/~/theos/sdks/iPhoneOS16.5.sdk/usr/include/mach/vm_map.h:184:14: note: passing argument to parameter ‘data’ here vm_offset_t data, ^ mem.c:98:12: error: unused variable ‘bytes’ [-Werror,-Wunused-variable] size_t bytes = strlen(in); ^ mem.c:194:38: error: incompatible integer to pointer conversion assigning to ‘vm_address_t ’ (aka ’unsigned long ’) from ‘unsigned long’ [-Werror,-Wint-conversion] outaddr = baseaddr+i; ^ ~~~~~~~~~~ mem.c:199:53: error: incompatible integer to pointer conversion assigning to ‘vm_address_t ’ (aka ’unsigned long ’) from ‘unsigned long’ [-Werror,-Wint-conversion] (outaddr + foundtotal) = baseaddr+i;\n\nYeah So This was a mess…\n\n\nResolving the Garbage Pile mess\nAfter 3 people (Mostly the Theos community) resloving this hot pile. We finally got a working build.\n \n\n\nOkay cool, a tool that… kinda works\nThe frontend application is null void. It will boot but preform zero tasks. The cli however does work, kinda. There is no proper tty to remember commands\nThe cli is really slow. Also have no way to fetch pids from within it, and doing that with\nps aux | grep containers | grep my ass | awk someone elses ass {FS = ” “;}{pid = $2;cid = $7; path = substr($11, index($11,\nyeah Im not doing that. I first wrote a shell script but… that wasn’t enough for me either. So I create another theos package iProcDump to nicely list all of processess with KERN_PROC, nicely sparsing it listing PIDS and Process name. I whipped it up pretty quickly being warmed up from the iFindMem. At some point it would be added to the main application.\n\n\nConclusion\nThere is a lot to be done as I would like to see some sort of decompiler like rizin or ghidra, being able to be used directly. After running iFindMem and find interesting memory addresses, you can start messing with them in a debugger/decompiler right away.\nI at some point have to go back to pwn related stuff, and especially revist assembly to get more into iOS Exploit/Jailbreak Development. I will make a few update posts for huge new releases regarding these topics,"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "SecOps",
    "section": "",
    "text": "iFindMem Development\n\n\n\n\n\n\niOS\n\n\nDevelopment\n\n\nOffSec\n\n\n\n\n\n\n\n\n\nMay 16, 2024\n\n\nRock3t\n\n\n\n\n\n\n\n\n\n\n\n\nFlashing Embedded Routers\n\n\n\n\n\n\nEmbedded Systems\n\n\nBlue\n\n\n\n\n\n\n\n\n\nApr 24, 2024\n\n\nRock3t\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog\nThis blog documents my journey in the Security Realm. Offering both Technical and Shop talk. I have been doing Security Operations for 11 years. Starting off with Blackhat operations when I was a lot younger.\nNowadays I ethically explore both Red and Blue team topics. Some in depth. Stick around, you may learn something or find a resource not previously known!\nLanguages: Rust, C/C++, ObjC, Ruby, Solidity, Python, Haskel, javascript"
  },
  {
    "objectID": "posts/ddwrt-embedded-firmware/index.html",
    "href": "posts/ddwrt-embedded-firmware/index.html",
    "title": "Flashing Embedded Routers",
    "section": "",
    "text": "What is DDWRT?\nDD-WRT is a Linux-based firmware for embedded wireless routers and access points, originally designed for the Linksys WRT54G series but now compatible with a wide range of models. Developed by Sebastian Gottschall, also known as “BrainSlayer,” DD-WRT turns a basic off the shelf router into a enterprise beast to be reckoned with. Features include, advanced quality of service, wireless bridging, Radius Authentication, VLANs, SIP, support for VPNs. (if routers powerful enough you could even run snort from the router hardware.) This open-source firmware provides a robust alternative to standard manufacturer firmware, aiming to increase the functionality and performance of supported devices. The project, which began as a response to commercial firmware that limited user control, continues to evolve, offering features not found in original or even other third-party firmware solutions\nOther embedded System alternative (only supports broadcom chipsets): Fresh Tomato\n\n\nInstallation/Flash\n\nStep 1: Download the Correct Firmware\nNavigate to the router database. Visit the DD-WRT Router Database and search the database to find the firmware specific to your router model. If it does not show up your device is not supported. However, it’s important to note:\n\nNever download router firmware files directly from the router database. Always check the forums for the latest advice and links to firmware as these are often more up to date and reliable.\nThere are multiple files, Init flash and update flash. The initial flash installs ddwrt onto your router, the next ‘flash’ is updating ddwrt\n\n\n\nStep 2: Fish the site for the forum post for your installation\nYou will find this forum to be a bit messy. But don’t be scared its relatively simple. In the database you will see a link “DD-WRT Wiki: Installation Instructions”\n\nEventually we will find the proper install link And land on this page:\n\n\nClick the latest build it, it will be the build-date and firmware version:\n \nFind your router:\n\nDownload both files. The factory-to-ddwrt will be the file you use for NetGear Genie (or whatever your routers gui’s name is)\n\n\n\nStep 3: Prepare for Installation\n\nBackup your current settings: Before proceeding, save your current router settings just in case you need to revert.\nReset your router to factory defaults: This can prevent issues during the flashing process. (Proceed to your routers documentation for that)\n\n\n\nStep 4: Flash Firmware via Web GUI\n\nConnect your computer to the router using an Ethernet cable.\nAccess your router’s default admin page (usually 192.168.1.1).\nNavigate to the “Administration” tab and select “Firmware Upgrade”.\nClick “Browse” and select the DD-WRT firmware file you downloaded.\nClick “Upgrade” and wait for the process to complete. Do not interrupt this process as it might brick your router.\n\nMy Routers Gui looks like this:\n\nFor more information about bricking visit DD-WRT wiki\n\n\nStep 5: After Installation\n\nWait at least 5 minutes after the upgrade tool says it is complete to ensure the changes are fully applied.\nReboot your router manually by unplugging it from power and plugging it back in.\nAccess the DD-WRT control panel by entering 192.168.1.1 in your browser.\n\n\n\nStep 6: Final Setup\n\nReconfigure your router settings according to your needs. You might want to set up security settings, Wi-Fi passwords, and network names (SSIDs) again.\nExplore DD-WRT’s features such as setting up a VPN, adjusting QoS settings, or setting up a guest network.\n\n\n\nTroubleshooting\nIf you encounter issues:\n\nCheck if your router is truly bricked by trying to access the recovery mode.\nRefer to the DD-WRT wiki for troubleshooting tips or post a question in the DD-WRT forums.\n\nBy following these steps, you should be able to successfully install DD-WRT on your router and enjoy the enhanced features it offers. Remember, always proceed with caution and follow the instructions specific to your router model."
  }
]